#!/bin/sh

USAGE='find|foreach|new|restore|switch [<args>]'

PATH=$PATH:$(git --exec-path)
. git-sh-setup

switch_branch ()
{
	ref=$1
	# Check if branch exists
	git show-ref --verify --quiet "$ref" || exit $?
	git symbolic-ref HEAD "$ref" && git reset HEAD
}

# Search for path in each branch
cmd_find ()
{
	git for-each-ref --format='%(refname:short)' refs/heads |
	while read ref; do
		git ls-tree -r --name-only "refs/heads/$ref" |
		grep -q "$@" && echo "$ref"
	done
}

# Run command on each branch
cmd_foreach ()
{
	cur_branch=$(git symbolic-ref -q HEAD)

	git for-each-ref --format='%(refname)' refs/heads |
	while read ref; do
		switch_branch "$ref"
		eval "$@"
	done

	switch_branch "$cur_branch"
}

# Create empty branch
cmd_new ()
{
	branch=$1

	git symbolic-ref HEAD "refs/heads/$branch"
	rm -f "$GIT_DIR/index"
}

# Restore any files missing from the working tree
cmd_restore ()
{
	branch=$1

	cur_branch=$(git symbolic-ref -q HEAD)

	switch_branch "refs/heads/$branch"
	git ls-files -z -d | xargs -0 git checkout --

	switch_branch "$cur_branch"
}

# Switch branches without touching the working tree
cmd_switch ()
{
	branch=$1
	switch_branch "refs/heads/$branch"
}

command=

case "$1" in
find|foreach|new|restore|switch)
	command=$1
	;;
*)
	usage
	;;
esac
shift

"cmd_$command" "$@"

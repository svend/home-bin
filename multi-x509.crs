#!/usr/bin/env run-cargo-script
use std::env;
use std::io::prelude::*;
use std::io::{self, Error};
use std::process::{self, Command, Stdio};

const BEGIN: &'static str = "-----BEGIN";
const END: &'static str = "-----END";
const COMMAND: &'static str = "cat";

fn run_command(cmd_and_args: &Vec<String>, stdin: &str) -> Result<(), Box<Error>> {
    let cmd = cmd_and_args.iter().nth(0);
    let args: Vec<_> = cmd_and_args.iter().skip(1).collect();

    let mut child = Command::new(cmd.unwrap_or(&COMMAND.to_string()))
        .args(&args)
        .stdin(Stdio::piped())
        .spawn()?;

    child.stdin.as_mut().unwrap().write_all(stdin.as_bytes())?;
    child.wait()?;
    Ok(())
}

fn run() -> Result<(), Box<Error>> {
    // Drop name of program
    let command: Vec<_> = env::args().skip(1).collect();

    let stdin = io::stdin();
    let mut cert = Vec::new();

    for line in stdin.lock().lines() {
        let l = line?;
        if l.starts_with(BEGIN) || !cert.is_empty() {
            cert.push(l.clone());
            if l.starts_with(END) {
                run_command(&command, &format!("{}\n", cert.join("\n")))?;
                cert.clear();
            }
        }
    }
    Ok(())
}

fn main() {
    if let Err(err) = run() {
        println!("error: {}", err);
        process::exit(1);
    }
}

fn add(x: i32, y: i32) -> i32 {
    return x + y;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }
}
